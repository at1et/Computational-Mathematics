#include <iostream>
#include <cmath>    // Для использования функций pow (возведение в степень) и других математических функций
using namespace std;

// ==========================================================================
// Определение функций для первого нелинейного уравнения:
// Уравнение: f1(x) = 7x + 5^x - 2 = 0
// ==========================================================================

// Функция f1(x) вычисляет значение функции 7x + 5^x - 2
double f1(double x) {
    return 7 * x + pow(5, x) - 2;
}

// Первая производная f1'(x) = 7 + 5^x * ln(5)
// Здесь ln(5) ≈ 1.609437
double f11(double x) {
    // Важно: используем точку в десятичном представлении числа 1.609437
    return 7 + pow(5, x) * 1.609437;
}

// Вторая производная f1''(x) = 5^x * (ln(5))^2
// Здесь (ln(5))^2 ≈ 2.59029
double f111(double x) {
    return pow(5, x) * 2.59029;
}

// ==========================================================================
// Определение функций для второго нелинейного уравнения:
// Уравнение: f2(x) = -2x^3 - x^2 + 5x + 1 = 0
// ==========================================================================

// Функция f2(x) вычисляет значение функции -2x^3 - x^2 + 5x + 1
double f2(double x) {
    return -2 * pow(x, 3) - pow(x, 2) + 5 * x + 1;
}

// Первая производная f2'(x) = -6x^2 - 2x + 5
double f22(double x) {
    return -6 * pow(x, 2) - 2 * x + 5;
}

// Вторая производная f2''(x) = -12x - 2
double f222(double x) {
    return -12 * x - 2;
}

// ==========================================================================
// Метод половинного деления (бисекции) для уравнения f1(x) = 0
// ==========================================================================

// Функция HalfDiv1 вычисляет корень уравнения f1(x) = 0 методом половинного деления.
// Параметры:
//    a   - левая граница интервала поиска,
//    b   - правая граница интервала поиска,
//    eps - требуемая точность (минимальная длина интервала).
double HalfDiv1(double a, double b, double eps) {
    double c; // c - середина текущего интервала [a, b]

    // Продолжаем делить интервал, пока его длина больше 2*eps
    while (b - a > 2 * eps) {
        // Вычисляем середину интервала
        c = (a + b) / 2;

        // Если знак функции на концах отрезка [a, c] разный,
        // значит, корень находится между a и c.
        if (f1(a) * f1(c) < 0) {
            b = c;  // обновляем правую границу интервала
        }
        // Иначе, если знак функции на концах отрезка [c, b] разный,
        // корень находится между c и b.
        else if (f1(b) * f1(c) < 0) {
            a = c;  // обновляем левую границу интервала
        }
        // Если ни одно из условий не выполняется, то функция в точке c может быть равна нулю.
    }
    // Возвращаем середину последнего интервала как приближённое значение корня
    return (a + b) / 2;
}

// ==========================================================================
// Метод половинного деления для уравнения f2(x) = 0
// ==========================================================================

// Функция HalfDiv2 вычисляет корень уравнения f2(x) = 0 методом бисекции
// и выводит результат. Параметры такие же, как и у HalfDiv1.
void HalfDiv2(double a, double b, double eps) {
    double c; // c - середина текущего интервала [a, b]

    // Цикл продолжается до достижения требуемой точности
    while (b - a > 2 * eps) {
        c = (a + b) / 2;

        // Если на интервале [a, c] функция меняет знак,
        // корень находится между a и c.
        if (f2(a) * f2(c) < 0) {
            b = c;
        }
        // Если на интервале [c, b] функция меняет знак,
        // корень находится между c и b.
        else if (f2(b) * f2(c) < 0) {
            a = c;
        }
    }
    // Выводим найденный корень, взятый как середина интервала
    cout << "x = " << (a + b) / 2 << endl;
}

// ==========================================================================
// Поиск всех интервалов, где функция f2(x) меняет знак, с последующим применением метода бисекции
// ==========================================================================

// Функция SearchHalfDiv2 проходит по интервалам от -100 до 100 и для каждого промежутка [i, i+1],
// где функция f2(x) меняет знак (f2(i) * f2(i+1) < 0), вызывает метод половинного деления.
void SearchHalfDiv2() {
    for (int i = -100; i < 100; i++) {
        // Если произведение значений функции на концах интервала отрицательно,
        // значит, на этом отрезке есть хотя бы один корень.
        if (f2(i) * f2(i + 1) < 0) {
            // Вызываем метод половинного деления с точностью 0.0001
            HalfDiv2(i, i + 1, 0.0001);
        }
    }
}

// ==========================================================================
// Комбинированный метод хорд и касательных для уравнения f1(x) = 0
// ==========================================================================

// Функция HordAndKas1 использует комбинированный метод (метод касательных и метод хорд)
// для поиска корня уравнения f1(x) = 0 на отрезке [a, b] с заданной точностью eps.
void HordAndKas1(double a, double b, double eps) {
    double d, c; // d - новое приближение, полученное методом касательных,
    // c - новое приближение, полученное методом хорд (секущих)

// Итерационный процесс, пока длина интервала [a, b] не станет меньше 2*eps.
    while (b - a > 2 * eps) {
        // Если значение функции в точке a и вторая производная в a имеют одинаковый знак,
        // то метод касательных сходится, начиная с точки a.
        if (f1(a) * f111(a) > 0) {
            // Метод касательных (Ньютона): вычисляем новое приближение для левой границы
            d = a - f1(a) / f11(a);
            // Метод хорд: вычисляем новое приближение для правой границы по формуле пересечения хорды
            c = (a * f1(b) - b * f1(a)) / (f1(b) - f1(a));
            // Обновляем границы интервала: a принимает значение d, b – значение c
            a = d;
            b = c;
        }
        // Если условие с левой границей не выполняется, то проверяем правую границу:
        // если f1(b) и f1''(b) имеют одинаковый знак, метод касательных сходится от точки b.
        else if (f1(b) * f111(b) > 0) {
            // Обновляем приближение для правой границы методом касательных
            d = b - f1(b) / f11(b);
            // Вычисляем новое приближение для левой границы по методу хорд
            c = (a * f1(b) - b * f1(a)) / (f1(b) - f1(a));
            // Обновляем интервал: b становится равным d, a – значению c
            b = d;
            a = c;
        }
    }
    // После завершения итераций выводим найденный корень как середину оставшегося интервала
    cout << "x = " << (a + b) / 2 << endl;
}

// ==========================================================================
// Комбинированный метод хорд и касательных для уравнения f2(x) = 0
// ==========================================================================

// Функция HordAndKas2 аналогична HordAndKas1, но применяется для функции f2(x).
void HordAndKas2(double a, double b, double eps) {
    double d, c; // d – новое приближение по методу касательных, c – по методу хорд

    // Итерационный процесс до достижения требуемой точности (интервал меньше 2*eps)
    while (b - a > 2 * eps) {
        // Если f2(a) и вторая производная f2''(a) имеют одинаковый знак,
        // то метод касательных будет сходиться, начиная с точки a.
        if (f2(a) * f222(a) > 0) {
            d = a - f2(a) / f22(a);   // Новое приближение для a по методу касательных
            c = (a * f2(b) - b * f2(a)) / (f2(b) - f2(a)); // Новое приближение для b по методу хорд
            a = d;
            b = c;
        }
        // Аналогично проверяем правую границу: если f2(b) и f2''(b) имеют одинаковый знак,
        // то обновляем приближения, начиная с точки b.
        else if (f2(b) * f222(b) > 0) {
            d = b - f2(b) / f22(b);   // Новое приближение для b по методу касательных
            c = (a * f2(b) - b * f2(a)) / (f2(b) - f2(a)); // Новое приближение для a по методу хорд
            b = d;
            a = c;
        }
    }
    // Выводим найденное приближение корня как середину финального интервала
    cout << "x = " << (a + b) / 2 << endl;
}

// ==========================================================================
// Поиск всех интервалов для функции f2(x), где она меняет знак,
// с последующим применением комбинированного метода хорд и касательных
// ==========================================================================

// Функция SearchHordAndKas2 проходит по интервалам от -100 до 100 и для каждого промежутка [i, i+1],
// где функция f2(x) меняет знак, вызывает HordAndKas2.
void SearchHordAndKas2() {
    for (int i = -100; i < 100; i++) {
        if (f2(i) * f2(i + 1) < 0) {
            HordAndKas2(i, i + 1, 0.0001);
        }
    }
}

// ==========================================================================
// Функция main - точка входа в программу
// ==========================================================================

int main() {
    // Устанавливаем русскую локаль для корректного отображения русских символов в консоли
    setlocale(LC_ALL, "RUSSIAN");

    // Объявляем переменные для границ интервала, найденного корня и точности вычислений
    double a, b, c, x, eps;

    // Задаём интервал для решения первого уравнения (например, от 0 до 1)
    a = 0;
    b = 1;
    // Устанавливаем требуемую точность для первого уравнения
    eps = 0.00000013;

    // ============================
    // Решение первого уравнения
    // f1(x) = 7x + 5^x - 2 = 0
    // ============================
    cout << "*** Уравнение 1 ***" << endl;

    // Решение методом половинного деления (бисекции)
    cout << "Половинное деление " << endl;
    // Вычисляем корень и сохраняем его в переменную x
    x = HalfDiv1(a, b, eps);
    cout << "x = " << x << endl;

    // Решение методом хорд и касательных (комбинированный метод)
    cout << "Хорды и касательные " << endl;
    HordAndKas1(a, b, eps);

    // ============================
    // Решение второго уравнения
    // f2(x) = -2x^3 - x^2 + 5x + 1 = 0
    // ============================
    cout << endl;
    cout << "*** Уравнение 2 ***" << endl;

    // Решение методом половинного деления для f2(x)
    cout << "Половинное деление " << endl;
    // Функция SearchHalfDiv2 ищет интервалы, где функция меняет знак, и на каждом таком отрезке
    // методом бисекции вычисляет корень.
    SearchHalfDiv2();

    // Решение методом хорд и касательных для f2(x)
    cout << "Хорды и касательные " << endl;
    SearchHordAndKas2();

    return 0; 
}
