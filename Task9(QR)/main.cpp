#include <iostream>
#include <cmath>

int main() {
    // Устанавливаем локаль для корректного вывода русских символов
    setlocale(LC_ALL, "Russian");

    // Задаём размер квадратной матрицы A (n x n)
    const int n = 5;

    // Исходная матрица A, для которой будет найдено QR-разложение.
    // QR-разложение позволяет представить матрицу A в виде A = Q * R,
    // где Q — ортогональная матрица (столбцы ортонормированы),
    // а R — верхнетреугольная матрица.
    double A[n][n] = { {3, 8, 2, 2, 8},
                       {4, 5, 9, 9, 9},
                       {2, 9, 8, 9, 6},
                       {4, 3, 7, 4, 3},
                       {3, 1, 9, 8, 4} };

    // Матрица Q будет содержать ортонормированные столбцы,
    // т.е. в итоге получится ортогональная матрица.
    double Q[n][n];

    // Матрица R — верхнетреугольная матрица, которая содержит коэффициенты
    // при представлении исходных векторов (столбцов A) через ортонормированные векторы.
    // Изначально инициализируем все элементы нулями.
    double R[n][n] = { 0 };

    // Копируем матрицу A в матрицу Q, поскольку алгоритм Грама–Шмидта будет
    // преобразовывать столбцы матрицы A в ортонормированные столбцы.
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            Q[i][j] = A[i][j];
        }
    }

    // Основной цикл алгоритма Грама–Шмидта по столбцам матрицы Q.
    // Переменная j отвечает за текущий столбец, который мы ортонормируем.
    for (int j = 0; j < n; ++j) {
        // Находим норму (длину) столбца j.
        // Для этого сначала вычисляем сумму квадратов элементов столбца.
        double SQsum = 0;
        for (int m = 0; m < n; ++m) {
            SQsum += Q[m][j] * Q[m][j];  // Суммируем квадраты элементов столбца j
        }

        // Норма столбца j — это квадратный корень из суммы квадратов.
        // Записываем её в диагональный элемент R[j][j] матрицы R.
        R[j][j] = sqrt(SQsum);

        // Нормализуем столбец j, деля каждый элемент на его норму.
        // В результате столбец становится единичной длины.
        for (int i = 0; i < n; ++i) {
            Q[i][j] /= R[j][j];
        }

        // Для всех последующих столбцов (с индексами k от j+1 до n-1)
        // устраняем компоненту, которая может быть неортогональной по отношению к текущему столбцу j.
        for (int k = j + 1; k < n; ++k) {
            // Вычисляем коэффициент проекции столбца k на текущий ортонормированный столбец j.
            // Это соответствует скалярному произведению между ними.
            for (int m = 0; m < n; ++m) {
                R[j][k] += Q[m][j] * Q[m][k];
            }
            // Вычитаем из столбца k его проекцию на столбец j,
            // чтобы сделать столбцы Q взаимно ортогональными.
            for (int i = 0; i < n; ++i) {
                Q[i][k] -= Q[i][j] * R[j][k];
            }
        }
    }

    // Выводим полученную ортогональную матрицу Q на экран.
    std::cout << "Матрица Q:" << std::endl;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cout << Q[i][j] << " ";
        }
        std::cout << std::endl;
    }

    // Выводим полученную верхнетреугольную матрицу R на экран.
    std::cout << "Матрица R:" << std::endl;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cout << R[i][j] << " ";
        }
        std::cout << std::endl;
    }

}
