#include <iostream>
#include <vector>
#include <iomanip>  // Для форматированного вывода чисел
#include <cmath>    // Для функции abs()

using namespace std;

// Функция для красивого вывода матрицы на экран.
// Принимает ссылку на двумерный вектор (матрицу) с элементами типа double.
void printMatrix(vector<vector<double>>& mat) {
    // Проходим по каждой строке матрицы.
    for (int i = 0; i < mat.size(); i++) {
        // Для каждой строки проходим по каждому столбцу.
        for (int j = 0; j < mat[0].size(); j++) {
            // Выводим число с форматированием:
            // setw(8) - отводим 8 символов на число,
            // fixed и setprecision(3) - фиксированное число знаков после запятой (3 знака).
            cout << setw(8) << fixed << setprecision(3) << mat[i][j] << " ";
        }
        // Переход на новую строку после вывода всех столбцов текущей строки.
        cout << endl;
    }
}

int main() {
    setlocale(LC_ALL, "Russian");
    // Задаём количество уравнений в системе (и размерность квадратной части расширенной матрицы).
    int n = 5;

    // Определяем расширенную матрицу системы уравнений.
    // Последний столбец содержит свободные члены системы.
    // Каждая внутренняя вектор-строка представляет одно уравнение.
    vector<vector<double>> B = {
         {3, 8, 2, 2, 8, 1},
         {4, 5, 9, 9, 9, 2},
         {2, 9, 8, 9, 6, 3},
         {4, 3, 7, 4, 3, 4},
         {3, 1, 9, 8, 4, 5}
    };

    // Основной цикл метода Гаусса–Жордана.
    // Здесь k - номер текущего шага (индекс строки/столбца, который будем обрабатывать).
    for (int k = 0; k < n; k++) {
        // *********** Шаг 1: Поиск ведущего элемента (Partial Pivoting) ***********
        // Выбираем строку с максимальным модулем элемента в k-м столбце.
        int pivot_row = k;  // Изначально считаем, что текущая строка k является ведущей.
        for (int i = k + 1; i < n; ++i) {
            // Если модуль текущего элемента больше, чем модуль текущего ведущего элемента,
            // обновляем индекс строки с ведущим элементом.
            if (abs(B[i][k]) > abs(B[pivot_row][k])) {
                pivot_row = i;
            }
        }

        // Если найденная строка с ведущим элементом не совпадает с текущей, меняем их местами.
        swap(B[k], B[pivot_row]);

        // Проверяем, что ведущий элемент не равен нулю.
        // Если равен нулю, система либо вырождена, либо имеет бесконечное число решений.
        double pivot = B[k][k];
        if (pivot == 0) {
            cerr << "Ошибка: система не имеет единственного решения!" << endl;
            return 1;
        }

        // Шаг 2: Нормализация ведущей строки 
        // Делим все элементы k-й строки (начиная с k-го столбца до последнего)
        // на значение ведущего элемента, чтобы получить 1 на диагонали.
        for (int j = k; j < n + 1; j++) {
            B[k][j] /= pivot;
        }

        //  Шаг 3: Обнуление элементов в k-м столбце во всех остальных строках 
        // Цель: привести матрицу к диагональному (единичной) виду, где в k-м столбце
        // во всех строках, кроме k-й, стоит 0.
        for (int i = 0; i < n; i++) {
            // Пропускаем ведущую строку, так как в ней уже стоит 1 в нужном месте.
            if (i != k) {
                // Коэффициент, на который нужно домножить k-ю строку для обнуления элемента в i-й строке.
                double factor = B[i][k];
                // Вычитаем из i-й строки ведущую строку, умноженную на этот коэффициент.
                // Таким образом, элемент B[i][k] становится равным 0.
                for (int j = k; j < n + 1; j++) {
                    B[i][j] -= factor * B[k][j];
                }
            }
        }

        // Выводим промежуточное состояние матрицы после каждого шага.
        cout << "Состояние матрицы после шага " << k + 1 << ":\n";
        printMatrix(B);
        cout << "\n";  // Пустая строка для разделения итераций.
    }

    //  Финальный вывод решения 
    // После завершения метода Гаусса–Жордана расширенная матрица находится в редуцированном виде.
    // Последний столбец содержит найденные значения переменных.
    cout << "Результат решения системы:\n";
    for (int i = 0; i < n; i++) {
        // Вывод решения для i-й переменной.
        // Переменные нумеруются с 1 (x1, x2, ..., xn).
        cout << "x" << i + 1 << " = " << B[i][n] << endl;
    }

    return 0;
}
